\documentclass{article}


\usepackage{msc}

%% prot syntax
\newcommand{\store}{\leftarrow}
\newcommand{\getR}{\stackrel{R}{\store}}

%% symbols
\newcommand{\sfsk}{\mathit{sk}}
\newcommand{\sfpk}{\mathit{pk}}
\newcommand{\sfss}{\mathit{ss}}
\newcommand{\sfct}{\mathit{ct}}

%% functions
\newcommand{\kwf}[1]{\mathrm{#1}}
\newcommand{\dhkeygen}{\kwf{DH.Keygen()}}
\newcommand{\kemkeygen}{\kwf{KEM.Keygen()}}
\newcommand{\encaps}{\kwf{KEM.Encaps}}
\newcommand{\aenckem}{\kwf{KEM.AEnc}}
\newcommand{\encapsr}{\kwf{encaps\_r}}
\newcommand{\decaps}{\kwf{KEM.Decaps}}
\newcommand{\dprf}{\kwf{dPRF}}
\newcommand{\hash}{\kwf{Hash}}
\newcommand{\kdf}{\kwf{KDF}}
\newcommand{\sign}{\kwf{SIG.Sign}}
\newcommand{\verify}{\kwf{SIG.Verify}}
\newcommand{\tagset}{\kwf{TAGS}}
\newcommand{\return}{\kwf{return}}

\begin{document}


\section{Protocols problem set}

This document presents four possible protocols that we propose to use for the protocol side of the crypto ladder. The proposed protocols are, ordered by increasing proof difficulty in the crypto world:
\begin{itemize}
\item Basic-Hash (Example~\ref{fig:basic-hash}), a RFID tag/reader access protocol, meant to provide unlinkability, a strong notion of anonymity, between the tags. This is the base pattern for electronic passport authentication.
\item Signed DH (Example~\ref{fig:dh}), a simple key-exchange providing secrecy and authentication,  which is the historic pattern for SSH/TLS.
\item Signed KEM (Example~\ref{fig:kem}), a bilateral authenticated variant relying on KEMs, illustrating subtle attacks against key-exchanges. 
\item  Signed DH+KEM (Example~\ref{fig:hybrid}), a hybrid variant with both KEM and DH following the pattern for the ongoing hybridization of SSH/TLS.
\item A simplified NTOR protocol (Example~\ref{fig:ntor}), a DH key-exchange using long term DH keys for authentication instead of signatures, which is the base pattern for Wireguard and PQXDH.
\end{itemize}

Rational behind this current set:
\begin{itemize}
\item provide a variety of security properties (secrecy, authentication, privacy);
\item have examples linked with widely deployed real-world applications or real-world attacks;
\item start with a very simple example and increase difficulty. 
\end{itemize}

Open questions:
\begin{itemize}
\item should we formalize the expected security properties for each problem ? The issue is that no common formalism might make sense for both the ProVerif/Tamarin side and the more crypto like tools.
\item should we consider advanced compromise scenarios for the key-exchanges (long term key compromise, ephemeral key compromise) ?  
\item is this too many examples ? too few ?  
  
\end{itemize}


\paragraph{Notations} Secret keys and key pairs are denoted by using the subscripts $\sfsk$/$\sfpk$ to distinguish between secret/public parts. We rely on usual algorithms for KEM, signatures and DH. We use a generic hash function $\hash$ without a fixed arity, modelers may use the most canonical way to represent those computations in their tools.

\subsection{Basic-Hash}\label{prob:basic-hash}

The protocol is given in Figure~\ref{fig:basic-hash}

\paragraph{Description} For a set $\tagset$ of valid identities, a RFID reader has a database of valid secret keys $\{t_\sfsk\}_{T \in \tagset}$. A RFID tag with identity $T$ and key $t_\sfsk$ authenticates to the reader by sampling a fresh challenge $n$, and sending the pair $(n,\hash(n,t_\sfsk))$ to the reader, which looks into its database to see if the hash can be mapped to a valid identity and then answers true or false.


\paragraph{Properties} This protocol should provide two guarantees against an active machine-in-the-middle attacker:
\begin{itemize}
\item non-injective authentication - if the reader accepts some message as coming from some tag, the corresponding tag did send this message at some point in the past.
\item unlinkability - it should be impossible to decide whether two sessions of the protocol correspond to the same tag or not. That is, it should be impossible to distinguish a scenario where there is a single tag executing $n$ times the protocol in sequence with a scenario where $n$ distinct tags all execute the protocol each a single time. 
\end{itemize}


Bonus: Show that injective authentication does not hold. The corresponding attack trace is given in Appendix~\ref{app:attacks}, Figure~\ref{fig:basic-hash-att}..

\begin{figure}

 % \setlength{\belowcaptionskip}{-15pt}
    \setmsckeyword{} \drawframe{no}
    \begin{center}
    \begin{msc}{}

        \setlength{\instwidth}{0\mscunit}
        \setlength{\instdist}{4cm}
        \setlength{\topheaddist}{0cm}

        \declinst{initiator}{
            \begin{tabular}[c]{c}
              $t_\sfsk$\\
              \fcolorbox{black}{white}{{\;\; \textsc{Tag} \;\;}}
            \end{tabular}}{}%
        \declinst{receiver}{
          \begin{tabular}[c]{c}
            $\{t_\sfsk\}_{T \in \tagset}$ \\
            \fcolorbox{black}{white}{{\;\;  \textsc{Reader} \;\;}}
          \end{tabular}}{}%
        \nextlevel[0]        
        \action*{$
          \begin{array}{@{}l@{}}
            n \getR \{0,1\}^\lambda\\
            auth = \hash(n,t_\sfsk)
          \end{array}$}{initiator}
        \nextlevel[4]
        \mess{$n, auth$}{initiator}{receiver}
        \nextlevel[1]        
        \action*{$
          \begin{array}{@{}l@{}}
            res =\\
            \quad            \texttt{if }\exists T \in \tagset, \hash(n,t_\sfsk) = auth\texttt{ then } \\
            \qquad true \\
            \quad \texttt{else} \\
            \qquad false
          \end{array}$}{receiver}
        \nextlevel[5.7]                
        \mess{$res$}{receiver}{initiator}
        
        
      \end{msc}
    \end{center}
      \caption{Basic Hash}\label{fig:basic-hash}    
\end{figure}



\subsection{signed DH key exchanges}

The protocol is given in Figure~\ref{fig:dh}.

 \paragraph{Description} The server has a long term signature keypair $s_\sfsk,s_\sfpk$.
This key is used to authenticate the server, while the client and the server exchange fresh DH values to derive a shared secret key.

\paragraph{Properties} This protocol should provide two guarantees against an active machine-in-the-middle attacker:
\begin{itemize}
\item injective unilateral client-side authentication - if a client derives a key with some parameters (the set of public keys), a corresponding server session derived the same key with the same parameters.
\item secrecy - nobody except the two matching sessions can derive the key.  The key might be proven to be indistinguishable from a random value.
\end{itemize}



\begin{figure}

 % \setlength{\belowcaptionskip}{-15pt}
    \setmsckeyword{} \drawframe{no}
    \begin{center}
    \begin{msc}{}

        \setlength{\instwidth}{0\mscunit}
        \setlength{\instdist}{4cm}
        \setlength{\topheaddist}{0cm}

        \declinst{initiator}{
            \begin{tabular}[c]{c}
              $s_\sfpk $\\
              \fcolorbox{black}{white}{{\;\; \textsc{Client} \;\;}}
            \end{tabular}}{}%
        \declinst{receiver}{
          \begin{tabular}[c]{c}
            $s_\sfsk $ \\
            \fcolorbox{black}{white}{{\;\;  \textsc{Server} \;\;}}
          \end{tabular}}{}%
        \nextlevel[0]        
        \action*{$
          \begin{array}{@{}l@{}}
           x_\sfsk, x_\sfpk \getR \dhkeygen 
          \end{array}$}{initiator}
        \nextlevel[4]
        \mess{$x_\sfpk$}{initiator}{receiver}
        \nextlevel[1]        
        \action*{$
          \begin{array}{@{}l@{}}
           y_\sfsk,y_\sfpk \getR \dhkeygen \\
            sig= \sign( (x_\sfpk, y_\sfpk), s_\sfsk)\\
                        k_S = \hash((x_\sfpk)^{y_\sfsk})
          \end{array}$}{receiver}
        \nextlevel[5.7]                
        \mess{$y_\sfpk,sig$}{receiver}{initiator}
        \nextlevel[1]                        
        \action*{$
          \begin{array}{@{}l@{}}
           \texttt{Abort if not } \verify(sig,  (x_\sfpk, y_\sfpk)  ,s_\sfpk) \\
            k_C = \hash((y_\sfpk)^{x_\sfsk})
          \end{array}$}{initiator}
        
        
      \end{msc}
          \end{center}
      \caption{signed Diffie-Hellman key exchange}\label{fig:dh}
\end{figure}


\subsection{signed KEM key exchanges}

The protocol is given in Figure~\ref{fig:kem}.

 \paragraph{Description} The client has a long term signature keypair $c_\sfsk,c_\sfpk$.
This key is used to authenticate the client, while the client and the server exchange fresh KEM values to derive a shared secret key.

\paragraph{Properties} This protocol should provide two guarantees against an active machine-in-the-middle attacker:
\begin{itemize}
\item bilateral authentication - TODO
\item secrecy - nobody except the two matching sessions can derive the key.  The key might be proven to be indistinguishable from a random value.
\end{itemize}


We want to consider in this problem a KEM that is just IND-CCA, the KEM may thus be implemented using an asymmetric encryption function $\aenckem$, and with
$$\encaps(x_\sfpk) := \sfss \getR \{0,1\}^\lambda; \sfct \getR \aenckem(\sfss,x_\sfpk); \return~(\sfct,\sfss)  $$

Shows that when instantiating the KEM with an asymmetric encryption of a fresh secret, this property does not hold.

Bonus: when considering a scenario where some clients are willing to talk to dishonest parties, this protocol suffers from an Unknown Key Share attack. The corresponding attack trace is given in Appendix~\ref{app:attacks}, Figure~\ref{fig:kem-uks}.


Bonus: when allowing attackers to compromise ephemeral keys $x_\sfsk$, we should on a good protocol still be able to prove that whenever a client session and a server session derive the same secret key, then if the corresponding client session $x_\sfsk$ was not compromised, the key is fully secret. This corresponds to session independence, where allowing to compromise the material of other sessions does not impact the security of uncomprommised sessions.  The corresponding attack trace is given in Appendix~\ref{app:attacks}, Figure~\ref{fig:kem-si}.


\begin{figure}

 % \setlength{\belowcaptionskip}{-15pt}
    \setmsckeyword{} \drawframe{no}
    \begin{center}
    \begin{msc}{}

        \setlength{\instwidth}{0\mscunit}
        \setlength{\instdist}{4cm}
        \setlength{\topheaddist}{0cm}

        \declinst{initiator}{
            \begin{tabular}[c]{c}
              $c_\sfsk $\\
              \fcolorbox{black}{white}{{\;\; \textsc{Client} \;\;}}
            \end{tabular}}{}%
        \declinst{receiver}{
          \begin{tabular}[c]{c}
            $c_\sfpk $ \\
            \fcolorbox{black}{white}{{\;\;  \textsc{Server} \;\;}}
          \end{tabular}}{}%
        \nextlevel[0]        
        \action*{$
          \begin{array}{@{}l@{}}
            x_\sfsk, x_\sfpk \getR \kemkeygen \\
            sig= \sign( x_\sfpk, c_\sfsk)
          \end{array}$}{initiator}
        \nextlevel[4]
        \mess{$x_\sfpk, sig$}{initiator}{receiver}
        \nextlevel[1]        
        \action*{$
          \begin{array}{@{}l@{}}
           \texttt{Abort if not } \verify(sig, x_\sfpk, c_\sfpk) \\
            { \sfct,\sfss  \getR \encaps(x_\sfpk) }\\
            k_S = ss
          \end{array}$}{receiver}
        \nextlevel[5.7]                
        \mess{$\sfct$}{receiver}{initiator}
        \nextlevel[1]                        
        \action*{$
          \begin{array}{@{}l@{}}
            {\sfss  \getR \decaps(\sfct,x_\sfsk) }\\
            k_C = ss
          \end{array}$}{initiator}
        
        
      \end{msc}
          \end{center}
      \caption{signed KEM key exchange}\label{fig:kem}
\end{figure}



\begin{figure}

 % \setlength{\belowcaptionskip}{-15pt}
    \setmsckeyword{} \drawframe{no}
    \begin{center}
    \begin{msc}{}

        \setlength{\instwidth}{0\mscunit}
        \setlength{\instdist}{4cm}
        \setlength{\topheaddist}{0cm}

        \declinst{initiator}{
            \begin{tabular}[c]{c}
              $c_\sfsk, s_\sfpk $\\
              \fcolorbox{black}{white}{{\;\; \textsc{Client} \;\;}}
            \end{tabular}}{}%
        \declinst{receiver}{
          \begin{tabular}[c]{c}
            $c_\sfpk, s_\sfsk $ \\
            \fcolorbox{black}{white}{{\;\;  \textsc{Server} \;\;}}
          \end{tabular}}{}%
        \nextlevel[0]        
        \action*{$
          \begin{array}{@{}l@{}}
            x_\sfsk, x_\sfpk \getR \kemkeygen \\
            { \sfct_1,\sfss_1  \getR \encaps(s_\sfpk) }\\            
            sig= \sign( x_\sfpk, c_\sfsk)
          \end{array}$}{initiator}
        \nextlevel[5]
        \mess{$x_\sfpk, sig, \sfct_1$}{initiator}{receiver}
        \nextlevel[1]        
        \action*{$
          \begin{array}{@{}l@{}}
            \texttt{Abort if not } \verify(sig, x_\sfpk, c_\sfpk) \\
            {\sfss_1  \getR \decaps(\sfct_1,s_\sfsk) }\\            
            { \sfct_2,\sfss_2  \getR \encaps(x_\sfpk) }\\
            k_S = \sfss_1 \| \sfss_2
          \end{array}$}{receiver}
        \nextlevel[5.7]                
        \mess{$\sfct_2$}{receiver}{initiator}
        \nextlevel[1]                        
        \action*{$
          \begin{array}{@{}l@{}}
            {\sfss_2  \getR \decaps(\sfct_2,x_\sfsk) }\\
            k_C  = \sfss_1 \| \sfss_2
          \end{array}$}{initiator}
        
        
      \end{msc}
          \end{center}
      \caption{signed KEM key exchange}\label{fig:kem}
\end{figure}


\subsection{signed DH+KEM key exchanges}

The protocol is given in Figure~\ref{fig:hybrid}.

 \paragraph{Description} The server has a long term signature keypair $s_\sfsk,s_\sfpk$. 
This key is used to authenticate the server, while the client and the server exchange fresh DH and KEM values to derive a shared secret key.

\paragraph{Properties} This protocol should provide two guarantees against an active machine-in-the-middle attacker:
\begin{itemize}
\item authentication - if a client derives a key with some parameters (the set of public keys), a corresponding server session derived the same key with the same parameters.
\item secrecy - nobody except the two matching sessions can derive the key.  The key might be proven to be indistinguishable from a random value.
\end{itemize}

Bonus: provides proofs where only either the KEM or the DH part is assumed secure.



\begin{figure}

 % \setlength{\belowcaptionskip}{-15pt}
    \setmsckeyword{} \drawframe{no}
    \begin{center}
    \begin{msc}{}

        \setlength{\instwidth}{0\mscunit}
        \setlength{\instdist}{4cm}
        \setlength{\topheaddist}{0cm}

        \declinst{initiator}{
            \begin{tabular}[c]{c}
              $s_\sfpk $\\
              \fcolorbox{black}{white}{{\;\; \textsc{Client} \;\;}}
            \end{tabular}}{}%
        \declinst{receiver}{
          \begin{tabular}[c]{c}
            $s_\sfsk $ \\
            \fcolorbox{black}{white}{{\;\;  \textsc{Server} \;\;}}
          \end{tabular}}{}%
        \nextlevel[0]        
        \action*{$
          \begin{array}{@{}l@{}}
           x_\sfsk,x_\sfpk \getR \dhkeygen \\
        { z_\sfsk,z_\sfpk \getR \kemkeygen }
          \end{array}$}{initiator}
        \nextlevel[4]
        \mess{$x_\sfpk, z_\sfpk$}{initiator}{receiver}
        \nextlevel[1]        
        \action*{$
          \begin{array}{@{}l@{}}
           y_\sfsk, y_\sfpk \getR \dhkeygen \\
            { \sfct,\sfss  \getR \encaps(z_\sfpk) }\\
            sig= \sign( (x_\sfpk, y_\sfpk, z_\sfpk, \sfct), s_\sfsk)\\
                        k_S = \hash((x_\sfpk)^{y_\sfsk}{,\sfss})
          \end{array}$}{receiver}
        \nextlevel[5.7]                
        \mess{$y_\sfpk,sig, {\sfct}$}{receiver}{initiator}
        \nextlevel[1]                        
        \action*{$
          \begin{array}{@{}l@{}}
           \texttt{Abort if not } \verify(sig, (x_\sfpk, y_\sfpk, z_\sfpk, \sfct), s_\sfpk) \\
            {\sfss  \getR \decaps(\sfct,z_\sfsk) }\\
            k_C = \hash((y_\sfpk)^{x_\sfsk}{,\sfss})
          \end{array}$}{initiator}
        
        
      \end{msc}
          \end{center}
      \caption{Hybridization of a signed Diffie-Hellman key exchange}\label{fig:hybrid}
\end{figure}



\subsection{full DH key exchanges}

The protocol is given in Figure~\ref{fig:ntor}.

 \paragraph{Description}The server has a long term DH keypar $s_\sfsk,s_\sfpk$.
This key is used to authenticate the server, while the client and the server exchange fresh DH values to derive a shared secret key. 

\paragraph{Properties} This protocol should provide two guarantees against an active machine-in-the-middle attacker:
\begin{itemize}
\item injective authentication - if a client derives a key with some parameters (the set of public keys), a corresponding server session derived the same key with the same parameters.
\item secrecy - nobody except the two matching sessions can derive the key.  The key might be proven to be indistinguishable from a random value.
\end{itemize}




\begin{figure}

 % \setlength{\belowcaptionskip}{-15pt}
    \setmsckeyword{} \drawframe{no}
    \begin{center}
    \begin{msc}{}

        \setlength{\instwidth}{0\mscunit}
        \setlength{\instdist}{4cm}
        \setlength{\topheaddist}{0cm}

        \declinst{initiator}{
            \begin{tabular}[c]{c}
              $s_\sfpk$\\
              \fcolorbox{black}{white}{{\;\; \textsc{Client} \;\;}}
            \end{tabular}}{}%
        \declinst{receiver}{
          \begin{tabular}[c]{c}
            $s_\sfsk $ \\
            \fcolorbox{black}{white}{{\;\;  \textsc{Server} \;\;}}
          \end{tabular}}{}%
        \nextlevel[0]        
        \action*{$
          \begin{array}{@{}l@{}}
           x_\sfsk,x_\sfpk \getR \dhkeygen 
          \end{array}$}{initiator}
        \nextlevel[4]
        \mess{$x_\sfpk,s_\sfpk$}{initiator}{receiver}
        \nextlevel[1]        
        \action*{$
          \begin{array}{@{}l@{}}
            y_\sfsk, y_\sfpk \getR \dhkeygen \\
            mk_S = \hash( x_\sfpk , y_\sfpk , s_\sfpk, (x_\sfpk)^{y_\sfsk}, (x_\sfpk)^{s_\sfsk})\\
            auth = \hash(mk_S, 0 ) \\
             k_S = \hash(mk_S, 1)
          \end{array}$}{receiver}
        \nextlevel[5.7]                
        \mess{$y_\sfpk,auth$}{receiver}{initiator}
        \nextlevel[1]                        
        \action*{$
          \begin{array}{@{}l@{}}
            mk_C =\hash( x_\sfpk , y_\sfpk , s_\sfpk, (y_\sfpk)^{x_\sfsk}, (s_\sfpk)^{x_\sfsk})\\
           \texttt{Abort if not }             auth = \hash( mk_C ,0)  \\
            k_C = \hash(mk_C, 1)
          \end{array}$}{initiator}
        
        
      \end{msc}
          \end{center}
      \caption{Simplified NTOR}\label{fig:ntor}
\end{figure}


\appendix

\section{Attack traces}\label{app:attacks}




\begin{figure}

 % \setlength{\belowcaptionskip}{-15pt}
    \setmsckeyword{} \drawframe{no}
    \begin{center}
    \begin{msc}{}

        \setlength{\instwidth}{0\mscunit}
        \setlength{\instdist}{4cm}
        \setlength{\topheaddist}{0cm}

        \declinst{initiator}{
            \begin{tabular}[c]{c}
              $t_\sfsk$\\
              \fcolorbox{black}{white}{{\;\; \textsc{Tag} \;\;}}
            \end{tabular}}{}%

        \declinst{attacker}{
            \begin{tabular}[c]{c}
              \\
              \fcolorbox{black}{white}{{\;\; \textsc{Attacker} \;\;}}
            \end{tabular}}{}%
          
        \declinst{receiver}{
          \begin{tabular}[c]{c}
            $\{t_\sfsk\}_{T \in \tagset}$ \\
            \fcolorbox{black}{white}{{\;\;  \textsc{Reader} \;\;}}
          \end{tabular}}{}%
        \nextlevel[0]        
        \action*{$
          \begin{array}{@{}l@{}}
            n \getR \{0,1\}^\lambda\\
            auth = \hash(n,t_\sfsk)
          \end{array}$}{initiator}
        \nextlevel[4]
        \mess{$n, auth$}{initiator}{attacker}
        \mess{$n, auth$}{attacker}{receiver}        
        \nextlevel[1]                      
        \mess{$true$}{receiver}{attacker}
        \mess{$true$}{attacker}{initiator}
        \nextlevel[1]
        \mess{$n, auth$}{attacker}{receiver}
        \nextlevel[1]        
                \mess{$true$}{receiver}{attacker}
        
        
      \end{msc}
    \end{center}
      \caption{Basic Hash - basic replay attack breaking injective authentication}\label{fig:basic-hash-att}    
\end{figure}



% \begin{figure}

%  % \setlength{\belowcaptionskip}{-15pt}
%     \setmsckeyword{} \drawframe{no}
%     \begin{center}
%     \begin{msc}{}

%         \setlength{\instwidth}{0\mscunit}
%         \setlength{\instdist}{4cm}
%         \setlength{\topheaddist}{0cm}

% \        \declinst{initiator}{
%             \begin{tabular}[c]{c}
%               $c_\sfsk $\\
%               \fcolorbox{black}{white}{{\;\; \textsc{Client} \;\;}}
%             \end{tabular}}{}%
%         \declinst{attacker}{
%             \begin{tabular}[c]{c}
%               $ $\\
%               \fcolorbox{black}{white}{{\;\; \textsc{Attacker} \;\;}}
%             \end{tabular}}{}%          
%         \declinst{receiver}{
%           \begin{tabular}[c]{c}
%             $c_\sfpk $ \\
%             \fcolorbox{black}{white}{{\;\;  \textsc{Server} \;\;}}
%           \end{tabular}}{}%
%         \nextlevel[0]                
%         \action*{$
%           \begin{array}{@{}l@{}}
%             x_\sfsk^c, x_\sfpk^c \getR \kemkeygen \\
%             sig^c= \sign( x_\sfpk, c_\sfsk)            \\
%             \textit{Continue execution of this session\dots}
%           \end{array}$}{initiator}
%         \nextlevel[5.5]           
%        \mess{Compromise $x_\sfsk^c, sig^c$}{initiator}{attacker}
%         \nextlevel[1]        
%         \action*{$
%           \begin{array}{@{}l@{}}\
%             \textit{Starting a fresh session}            \\
%             x_\sfsk, x_\sfpk \getR \kemkeygen \\
%             sig= \sign( x_\sfpk, c_\sfsk)
%           \end{array}$}{initiator}
%         \nextlevel[4.5]
%         \mess{$x_\sfpk, sig$}{initiator}{attacker}
%         \mess{$x_\sfpk^c, sig^c$}{attacker}{receiver}        
%         \nextlevel[1]        
%         \action*{$
%           \begin{array}{@{}l@{}}
%            \texttt{Abort if not } \verify(sig^c, x_\sfpk^c, c_\sfpk) \\
%             { \sfct,\sfss  \getR \encaps(x_\sfpk^c) }\\
%             k_S = ss
%           \end{array}$}{receiver}
%         \nextlevel[5.7]                
%         \mess{$\sfct$}{receiver}{attacker}
%         \nextlevel[1]
%         \nextlevel[1]        
%         \action*{$
%           \begin{array}{@{}l@{}}
%             { \sfss  \getR \decaps(x_\sfsk^c) }\\
%             \sfct'  \getR \aenckem(\sfss, x_\sfpk)
%           \end{array}$}{attacker}
%         \nextlevel[3.7]
%         \mess{$\sfct'$}{attacker}{initiator}
%         \nextlevel[1]                
%         \action*{$
%           \begin{array}{@{}l@{}}
%             {\sfss  \getR \decaps(\sfct',x_\sfsk) }\\
%             k_C = ss
%           \end{array}$}{initiator}
        
        
%       \end{msc}
%           \end{center}
%       \caption{signed KEM key exchange - reencapsulation attack}\label{fig:kem-att}
%     \end{figure}



\begin{figure}

 % \setlength{\belowcaptionskip}{-15pt}
    \setmsckeyword{} \drawframe{no}
    \begin{center}
    \begin{msc}{}

        \setlength{\instwidth}{0\mscunit}
        \setlength{\instdist}{4cm}
        \setlength{\topheaddist}{0cm}

        \declinst{initiator}{
            \begin{tabular}[c]{c}
              $c_\sfsk, a_\sfpk $\\
              \fcolorbox{black}{white}{{\;\;
              \begin{tabular}{c}
              \textsc{Client} \\ \textit{\footnotesize wants to talk to dishonest party}                
              \end{tabular}
 \;\;}}
            \end{tabular}}{}%
        \declinst{attacker}{
            \begin{tabular}[c]{c}
              $a_\sfsk $\\
              \fcolorbox{black}{white}{{\;\; \textsc{Attacker} \;\;}}
            \end{tabular}}{}%          
        \declinst{receiver}{
          \begin{tabular}[c]{c}
            $c_\sfpk, s_\sfpk $ \\
            \fcolorbox{black}{white}{{\;\;
            \begin{tabular}{c}
            \textsc{Server} \\ \textit{\footnotesize wants to talk to honest client}              
            \end{tabular}
 \;\;}}
          \end{tabular}}{}%
        \nextlevel[0]                
        \action*{$
          \begin{array}{@{}l@{}}\
            x_\sfsk, x_\sfpk \getR \kemkeygen \\
            { \sfct_1,\sfss_1  \getR \encaps(a_\sfpk) }\\                        
            sig= \sign( x_\sfpk, c_\sfsk)
          \end{array}$}{initiator}
        \nextlevel[5.5]
        \mess{$x_\sfpk, sig, \sfct_1$}{initiator}{attacker}
        \action*{$
          \begin{array}{@{}l@{}}
            { \sfss_1  \getR \decaps(\sfct_1, a_\sfsk) }\\
            \sfct_1'  \getR \aenckem(\sfss_1, s_\sfpk)
          \end{array}$}{attacker}
        \nextlevel[4.7]        
        \mess{$x_\sfpk, sig, \sfct_1'$}{attacker}{receiver}        
        \nextlevel[1]        
        \action*{$
          \begin{array}{@{}l@{}}
            \texttt{Abort if not } \verify(sig^c, x_\sfpk^c, c_\sfpk) \\
            {\sfss_1  \getR \decaps(\sfct_1',s_\sfsk) }\\             
            { \sfct_2,\sfss_2  \getR \encaps(x_\sfpk^c) }\\
            k_S =  \sfss_1 \| \sfss_2
          \end{array}$}{receiver}
        \nextlevel[5.7]                
        \mess{$\sfct_2$}{receiver}{attacker}
        \nextlevel[1]
        \nextlevel[1]        

        \mess{$\sfct_2$}{attacker}{initiator}
        \nextlevel[1]                
        \action*{$
          \begin{array}{@{}l@{}}
            {\sfss_2  \getR \decaps(\sfct_2',x_\sfsk) }\\
            k_C =  \sfss_1\| \sfss_2
          \end{array}$}{initiator}
        
        
      \end{msc}
          \end{center}
          \caption{signed KEM key exchange - Unknown Key-share Attack through reencapsulation attack . \\
            Both honest client and honest server derive the same key, but do not believe to be talking together.
}\label{fig:kem-uks}
\end{figure}




\begin{figure}

 % \setlength{\belowcaptionskip}{-15pt}
    \setmsckeyword{} \drawframe{no}
    \begin{center}
    \begin{msc}{}

        \setlength{\instwidth}{0\mscunit}
        \setlength{\instdist}{4cm}
        \setlength{\topheaddist}{0cm}

        \declinst{initiator}{
            \begin{tabular}[c]{c}
              $c_\sfsk, s_\sfpk $\\
              \fcolorbox{black}{white}{{\;\; \textsc{Client} \;\;}}
            \end{tabular}}{}%
        \declinst{attacker}{
            \begin{tabular}[c]{c}
              $ $\\
              \fcolorbox{black}{white}{{\;\; \textsc{Attacker} \;\;}}
            \end{tabular}}{}%          
        \declinst{receiver}{
          \begin{tabular}[c]{c}
            $c_\sfpk, s_\sfpk $ \\
            \fcolorbox{black}{white}{{\;\;  \textsc{Server} \;\;}}
          \end{tabular}}{}%
        \nextlevel[0]                
        \action*{$
          \begin{array}{@{}l@{}}
            x_\sfsk^c, x_\sfpk^c \getR \kemkeygen \\
            { \sfct_1^c,\sfss_1^c  \getR \encaps(s_\sfpk) }\\                        
            sig^c= \sign( x_\sfpk, c_\sfsk)            \\
            \textit{Continue execution of this session as usual\dots}
          \end{array}$}{initiator}
        \nextlevel[6.5]           
       \mess{Compromise $x_\sfsk^c, sig^c$}{initiator}{attacker}
        \nextlevel[1]        
        \action*{$
          \begin{array}{@{}l@{}}\
            \textit{Starting a fresh session}            \\
            x_\sfsk, x_\sfpk \getR \kemkeygen \\
            { \sfct_1,\sfss_1  \getR \encaps(s_\sfpk) }\\                        
            sig= \sign( x_\sfpk, c_\sfsk)
          \end{array}$}{initiator}
        \nextlevel[5.5]
        \mess{$x_\sfpk, sig, \sfct_1$}{initiator}{attacker}
        \mess{$x_\sfpk^c, sig^c, \sfct_1$}{attacker}{receiver}        
        \nextlevel[1]        
        \action*{$
          \begin{array}{@{}l@{}}
            \texttt{Abort if not } \verify(sig^c, x_\sfpk^c, c_\sfpk) \\
            {\sfss_1  \getR \decaps(\sfct_1,s_\sfsk) }\\             
            { \sfct_2,\sfss_2  \getR \encaps(x_\sfpk^c) }\\
            k_S =  \sfss_1 \| \sfss_2
          \end{array}$}{receiver}
        \nextlevel[5.7]                
        \mess{$\sfct_2$}{receiver}{attacker}
        \nextlevel[1]
        \nextlevel[1]        
        \action*{$
          \begin{array}{@{}l@{}}
            { \sfss_2  \getR \decaps(\sfct_2, x_\sfsk^c) }\\
            \sfct_2'  \getR \aenckem(\sfss_2, x_\sfpk)
          \end{array}$}{attacker}
        \nextlevel[4.7]
        \mess{$\sfct_2'$}{attacker}{initiator}
        \nextlevel[1]                
        \action*{$
          \begin{array}{@{}l@{}}
            {\sfss_2  \getR \decaps(\sfct_2',x_\sfsk) }\\
            k_C =  \sfss_1\| \sfss_2
          \end{array}$}{initiator}
        
        
      \end{msc}
          \end{center}
          \caption{signed KEM key exchange - Reencapsulation attack against session independence. \\
            The attacker learns half of the key of a fresh session by compromising material from an independent session.}\label{fig:kem-si}
\end{figure}





\end{document}

%%% Local Variables:
%%% mode: LaTeX
%%% TeX-master: t
%%% End:
